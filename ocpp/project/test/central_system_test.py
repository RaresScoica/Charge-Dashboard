import asyncio
import json
import logging
import os
import random
import string
import requests
import websockets
import certifi

from dotenv import load_dotenv
from aio_pika import connect
from datetime import datetime, timedelta, timezone
from ocpp.routing import on
from ocpp.v16 import call
from ocpp.v16 import ChargePoint as cp
from ocpp.v16 import call_result
from ocpp.v16.enums import Action, RegistrationStatus, AvailabilityType
from pymongo.mongo_client import MongoClient
from pymongo.server_api import ServerApi

logging.basicConfig(filename='auto_app.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

uri = "mongodb+srv://raresgoiceanu:YuWNxuLNwVnMvNfd@csms.bxk3l53.mongodb.net/?retryWrites=true&w=majority&appName=CSMS"

mongoClient = MongoClient(uri, server_api=ServerApi('1'), tlsCAFile=certifi.where())

FIRMWARE_DIR = 'C:/Users/developer/Documents/ws-server'

class ChargePoint(cp):
    connected_charge_points = {}
    active_transactions = {}
    # Tags valid for authorization
    AUTHORIZED_TAGS = ['user123', 'user456', 'db759c11', '6bdeca11']

    @on(Action.BootNotification)
    def on_boot_notification(
        self, charge_point_vendor: str, charge_point_model: str, **kwargs):
        # Get the current time in UTC
        current_time_utc = datetime.now(timezone.utc)

        # Convert UTC time to GMT+2
        gmt_plus_2 = current_time_utc + timedelta(hours=3)

        print(f"Boot Notification for {self.id} at {current_time_utc}")

        return call_result.BootNotificationPayload(
            current_time=current_time_utc.isoformat(),
            interval=60,
            status=RegistrationStatus.accepted,
        )
        
    @on(Action.Heartbeat)
    def on_heartbeat(self):
        # Get the current time in UTC
        current_time_utc = datetime.now(timezone.utc)

        # Convert UTC time to GMT+2
        gmt_plus_2 = current_time_utc + timedelta(hours=3)

        # Format the time as string
        current_time = gmt_plus_2.strftime("%Y-%m-%dT%H:%M:%S") + "Z"
        
        print(f"{self.id}: Got a Heartbeat at {current_time}!")
        
        return call_result.HeartbeatPayload(
            current_time = current_time
        )
        
    @on(Action.Authorize)
    def on_authorize(self, id_tag):
        if id_tag not in self.AUTHORIZED_TAGS:
            self.AUTHORIZED_TAGS.append(id_tag)
        if id_tag in self.AUTHORIZED_TAGS:
            db = mongoClient['EV_Stations']
            collection = db['banned']
            result = collection.find_one({"Idtag": id_tag})
            if result:
                print(f"Authorization denied for id_tag: {id_tag}")
                return call_result.AuthorizePayload(
                    id_tag_info={'status': 'Blocked'}
                )
            else:
                print(f"Authorization accepted for id_tag: {id_tag}")
                return call_result.AuthorizePayload(
                    id_tag_info={'status': 'Accepted'}
                )
    
    @on(Action.StartTransaction)
    def on_start_transaction(self, connector_id, id_tag, meter_start, timestamp):
        db = mongoClient['EV_Stations']
        collectionCurrent = db['current_transaction']
        current_doc = collectionCurrent.find_one({'ID': 'current'})
        transaction_id = current_doc.get('currentId')
        increment = transaction_id + 1
        collectionCurrent.update_one({'ID': 'current'}, {'$set': {'currentId': increment}})

        collection = db['stations']
        collection.update_one({'sn': self.id}, {'$set': {'transactionId': transaction_id}})

        print(f"Charging started for charger {self.id} with ID: {transaction_id}")

        return call_result.StartTransactionPayload(
            transaction_id=transaction_id,
            id_tag_info={'status': 'Accepted'}
        )
    
    @classmethod
    def stop_transaction(cls, transaction_id, meter_stop, timestamp):
        if transaction_id in cls.active_transactions:
            charge_point = cls.active_transactions.pop(transaction_id)
            
    @on(Action.StopTransaction)
    def on_stop_transaction(self, transaction_id, meter_stop, timestamp, reason=None, transaction_data=None, id_tag=None):
        self.stop_transaction(transaction_id, meter_stop, timestamp)
        print(f"Charging stopped for charger {self.id} with ID: {transaction_id}")
        # self.handle_stopped_transaction(transaction_id, meter_stop, timestamp)
        return call_result.StopTransactionPayload(
            id_tag_info={'status': 'Accepted'}
        )   
    
    def handle_stopped_transaction(self, transaction_id, meter_stop, timestamp):
        print(f"Handling stopped transaction for transaction_id: {transaction_id}, meter_stop: {meter_stop}")
        stop_data = {
            "transactionId": str(transaction_id), # 6 symbols autogenerated string
            "portalLink": "charge.arsek.ro",
            "qrLink": f"charge.arsek.ro/{transaction_id}"
        }
        asyncio.create_task(
            self.data_transfer(vendor_id="xcharge", message_id="TransactionQrCode", data=json.dumps(stop_data)))

    @on(Action.GetDiagnostics)
    def on_get_diagnostics(self, location, retries, retryInterval):
        return call_result.GetDiagnosticsPayload()
    
    async def get_diagnostics(self, location, retries, retryInterval):
        request = call.GetDiagnosticsPayload(
                location=location,
                retries=retries,
                retry_interval=retryInterval
        )
        await self.call(request)

    async def send_get_diagnostics(charge_point_id, location, retries, retryInterval):
        async with websockets.connect(
            "ws://arsek-ws.duckdns.org:8765/{charge_point_id}".format(charge_point_id=charge_point_id)
        ) as ws:
            request = cp.on_get_diagnostics(
                location=location,
                retries=retries,
                retryInterval=retryInterval
            )
            response = await ws.send(request)

            print(f"GetDiagnostics response received: {response}")

    @on(Action.DiagnosticsStatusNotification)
    def on_diagnostics_status_notification(self, status):
        print(f"Received Diagnostics Status Notification")
        
        if status == 'Uploading':
            print("The station is uploading")
        
        return call_result.DiagnosticsStatusNotificationPayload()

    @on(Action.UpdateFirmware)
    def on_update_firmware(self, location, retrieve_date):
        return call_result.UpdateFirmwarePayload()
    
    async def update_firmware(self, location, retrieve_date):
        request = call.UpdateFirmwarePayload(
                location=location,
                retrieve_date=retrieve_date
        )
        await self.call(request)

    async def send_update_firmware(charge_point_id, location, retrieve_date):
        async with websockets.connect(
            "ws://arsek-ws.duckdns.org:8765/{charge_point_id}".format(charge_point_id=charge_point_id)
        ) as ws:
            request = cp.on_update_firmware(
                location=location,
                retrieve_date=retrieve_date
            )
            response = await ws.send(request)

            print(f"UpdateFirmware response received: {response}")

    @on(Action.FirmwareStatusNotification)
    def on_firmware_status_notification(self, status):
        print(f"Received Firmware Status Notification")
        
        return call_result.FirmwareStatusNotificationPayload()

    @on(Action.ChangeConfiguration)
    def on_change_configuration(self, key, value):
        return call_result.ChangeConfigurationPayload(
            status="Accepted"
        )
    
    async def change_configuration(self, key, value):
        request = call.ChangeConfigurationPayload(
                key=key,
                value=value
        )
        await self.call(request)

    async def send_change_configuration(charge_point_id, key, value):
        async with websockets.connect(
            "ws://arsek-ws.duckdns.org:8765/{charge_point_id}".format(charge_point_id=charge_point_id)
        ) as ws:
            request = cp.on_change_configuration(
                key=key,
                value=value
            )
            response = await ws.send(request)

            print(f"ChangeConfiguration response received: {response}")

    @on(Action.ChangeAvailability)
    def on_change_availability(self, connector_id, type, **kwargs):
        # Handle the availability change
        if type == AvailabilityType.operative:
            logging.info(f"Charging station set to Operative (available)")
        elif type == AvailabilityType.inoperative:
            logging.info(f"Charging station set to Inoperative (unavailable)")
        else:
            logging.warning(f"Unsupported availability status: {type}")

        return call_result.ChangeAvailabilityPayload(
            status='Accepted'
        )

    async def change_availability(self, connector_id, type):
        request = call.ChangeAvailabilityPayload(
            connector_id=connector_id,
            type=type
        )
        await self.call(request)

    async def send_change_availability(charge_point_id, type):
        async with websockets.connect(
            "ws://arsek-ws.duckdns.org:8765/{charge_point_id}".format(charge_point_id=charge_point_id)
        ) as ws:
            request = cp.on_reset(type=type)
            response = await ws.send(request)
            logging.info(f"Reset response received: {response}")

    @on(Action.Reset)
    def on_reset(self, reset_type, **kwargs):
        # Handle the reset action
        if reset_type == 'Hard':
            logging.info("Performing a hard reset...")
            print("Performing a hard reset...")
            # Perform actions for a hard reset
        elif reset_type == 'Soft':
            logging.info("Performing a soft reset...")
            print("Performing a soft reset...")
            # Perform actions for a soft reset
        else:
            logging.warning(f"Unsupported reset type: {reset_type}")
            print(f"Unsupported reset type: {reset_type}")

        return call_result.ResetPayload(
            status='Accepted'
        )

    async def reset(self, reset_type):
        request = call.ResetPayload(
                type = reset_type
        )
        await self.call(request)
    
    async def send_reset_request(charge_point_id, reset_type):
        async with websockets.connect(
            "ws://arsek-ws.duckdns.org:8765/{charge_point_id}".format(charge_point_id=charge_point_id)
        ) as ws:
            request = cp.on_reset(reset_type=reset_type)
            response = await ws.send(request)
            logging.info(f"Reset response received: {response}")

    @on(Action.RemoteStartTransaction)
    def on_remote_start_transaction(self, connector_id, id_tag):
        print(f"Remote charging started for charger {self.id}")
        return call_result.RemoteStartTransactionPayload(
            status="Accepted"
        )
    
    async def remote_start_transaction(self, connector_id, id_tag):
        request = call.RemoteStartTransactionPayload(
                connector_id=connector_id, 
                id_tag=id_tag
        )
        await self.call(request)

    async def send_remote_start_transaction(charge_point_id, id_tag, connector_id):
        async with websockets.connect(
            "ws://arsek-ws.duckdns.org:8765/{charge_point_id}".format(charge_point_id=charge_point_id)
        ) as ws:
            request = cp.on_remote_start_transaction(
                id_tag=id_tag,
                connector_id=connector_id,
            )
            response = await ws.send(request)

            print(f"RemoteStartTransaction response received: {response}")

    @on(Action.RemoteStopTransaction)
    def on_remote_stop_transaction(self, transaction_id):
        print(f"Remote charging stopped for charger {self.id} with ID {transaction_id}")
        return call_result.RemoteStopTransactionPayload(
            status="Accepted"
        )
    
    async def remote_stop_transaction(self, transaction_id):
        request = call.RemoteStopTransactionPayload(
                transaction_id=transaction_id
        )
        await self.call(request)

    async def send_remote_stop_transaction(charge_point_id, transaction_id):
        async with websockets.connect(
            "ws://arsek-ws.duckdns.org:8765/{charge_point_id}".format(charge_point_id=charge_point_id)
        ) as ws:
            request = cp.on_remote_stop_transaction(
                transaction_id=transaction_id
            )
            response = await ws.send(request)

            print(f"RemoteStopTransaction response received: {response}")

    @on(Action.StatusNotification)
    def on_status_notification(self, connector_id, status, error_code, vendor_id=None, vendor_error_code=None, info=None, timestamp=None):
        """Handle incoming Status Notification messages from the charging station."""
        print(f"Received Status Notification for charger {self.id} and connector {connector_id}: Status - {status}")
        
        if status == 'Charging':
            print(f"{self.id} started charging")
        elif status == 'Available':
            print(f"{self.id} is available")
        elif status == 'Faulted':
            print(f"{self.id} faulted")
        
        return call_result.StatusNotificationPayload()

    @on(Action.MeterValues)
    def on_meter_values(self, connector_id, meter_value, transaction_id=None, **kwargs):
        """Meter Values are received once every minute"""
        print(f"{self.id}: Received meter values: {meter_value}")
        if 'reason' in meter_value and meter_value['reason'] == 'EVDisconnected':
            transaction_id = meter_value.get('transactionId')
            id_tag = meter_value.get('idTag')
            timestamp = meter_value.get('timestamp')

            print(f"StopTransaction received for connector {connector_id}: "
                f"Transaction ID - {transaction_id}, ID Tag - {id_tag}, Timestamp - {timestamp}")

        return call_result.MeterValuesPayload()
    
    @on(Action.DataTransfer)
    async def on_data_transfer(self, vendor_id, message_id, data, **kwargs):
        if vendor_id == "xcharge" and message_id == "tariff":
            try:
                data_dict = json.loads(data)
                
                fee_id = data_dict.get("feeId")
                fee_service = data_dict.get("feeService")
                currency_type = data_dict.get("currencyType")
                prepayment_amount = data_dict.get("prepaymentAmount")
                timed_price = data_dict.get("timedPrice")

                print(f"Received tariff change request:")
                print(f"Fee ID: {fee_id}")
                print(f"Fee Service: {fee_service}")
                print(f"Currency Type: {currency_type}")
                print(f"Prepayment Amount: {prepayment_amount}")
                print(f"Timed Price: {timed_price}")

                return call_result.DataTransferPayload(
                    status='Accepted',
                    data='{"result":"success"}'
                )
            except json.JSONDecodeError as e:
                logging.error(f"Error decoding JSON data: {e}")
                return call_result.DataTransferPayload(
                    status='Rejected',
                    data='{"result":"error", "message":"Invalid JSON data"}'
                )
            
        elif vendor_id == "xcharge" and message_id == "prepaymentValues":
            try:
                data_dict = json.loads(data)
                
                prepaymentOptions = data_dict.get("prepaymentOptions")

                print(f"Received price change request:")
                print(f"Prepayment Options: {prepaymentOptions}")

                return call_result.DataTransferPayload(
                    status='Accepted',
                    data='{"result":"success"}'
                )
            except json.JSONDecodeError as e:
                logging.error(f"Error decoding JSON data: {e}")
                return call_result.DataTransferPayload(
                    status='Rejected',
                    data='{"result":"error", "message":"Invalid JSON data"}'
                )
            
        elif vendor_id == "xcharge" and message_id == "TransactionQrCode":
            try:
                data_dict = json.loads(data)
                
                transactionId = data_dict.get("transactionId")
                portalLink = data_dict.get("portalLink")
                qrLink = data_dict.get("qrLink")

                print(f"Received price change request:")
                print(f"Transaction Id: {transactionId}")
                print(f"Portal Link: {portalLink}")
                print(f"QR Link: {qrLink}")

                return call_result.DataTransferPayload(
                    status='Accepted',
                    data='{"result":"success"}'
                )
            except json.JSONDecodeError as e:
                logging.error(f"Error decoding JSON data: {e}")
                return call_result.DataTransferPayload(
                    status='Rejected',
                    data='{"result":"error", "message":"Invalid JSON data"}'
                )
            
        elif vendor_id == "XCHARGE" and message_id == "checkAccounts":
            try:
                data_dict = json.loads(data)
                data_dict['sn'] = self.id

                # Query MongoDB to get kwPrice based on sn (self.id)
                db = mongoClient['EV_Stations']
                collection = db['stations']
                station_data = collection.find_one({'sn': self.id})

                kw_price = station_data.get('kwPrice')
                data_dict['kwPrice'] = kw_price

                await self.store_transaction_details(data_dict)
                
                stopTime = data_dict.get("StopTime")
                transactionId = data_dict.get("TransactionID")
                duration = data_dict.get("Duration")
                finalAmount = data_dict.get("finalAmount")
                vat = data_dict.get("VAT")
                preTaxAmount = data_dict.get("preTaxAmount")

                return call_result.DataTransferPayload(
                    status='Accepted',
                    data='{"result":"success"}'
                )
            except json.JSONDecodeError as e:
                logging.error(f"Error decoding JSON data: {e}")
                return call_result.DataTransferPayload(
                    status='Rejected',
                    data='{"result":"error", "message":"Invalid JSON data"}'
                )

        elif vendor_id == "xcharge" and message_id == "transactionDetails":
            try:
                data_dict = json.loads(data)
                data_dict['sn'] = self.id

                # Query MongoDB to get kwPrice based on sn (self.id)
                db = mongoClient['EV_Stations']
                collection = db['stations']
                station_data = collection.find_one({'sn': self.id})

                kw_price = station_data.get('kwPrice')
                data_dict['kwPrice'] = kw_price

                await self.store_transaction_details(data_dict)
                
                stopTime = data_dict.get("StopTime")
                transactionId = data_dict.get("TransactionID")
                duration = data_dict.get("Duration")
                finalAmount = data_dict.get("finalAmount")
                vat = data_dict.get("VAT")
                preTaxAmount = data_dict.get("preTaxAmount")

                print("Sending QR code data transfer...")
                stop_data = {
                    "transactionId": str(transactionId), # 6 symbols autogenerated string
                    "portalLink": "charge.arsek.ro",
                    "qrLink": f"charge.arsek.ro/{transactionId}"
                }

                asyncio.create_task(
                    self.data_transfer(vendor_id="xcharge", message_id="TransactionQrCode", data=json.dumps(stop_data)))

                return call_result.DataTransferPayload(
                    status='Accepted',
                    data='{"result":"success"}'
                )
            except json.JSONDecodeError as e:
                logging.error(f"Error decoding JSON data: {e}")
                return call_result.DataTransferPayload(
                    status='Rejected',
                    data='{"result":"error", "message":"Invalid JSON data"}'
                )
            
        else:
            logging.warning(f"Unsupported DataTransfer action: Vendor ID - {vendor_id}, Message ID - {message_id}")
            return call_result.DataTransferPayload(
                status='Rejected',
                data='{"result":"error", "message":"Unsupported action"}'
            )
        
    async def data_transfer(self, vendor_id, message_id, data):
        request = call.DataTransferPayload(
            vendor_id=vendor_id,
            message_id=message_id,
            data=data
        )
        await self.call(request)

    async def send_data_transfer(charge_point_id, vendor_id, message_id, data):
        try:
            async with websockets.connect(
                "ws://arsek-ws.duckdns.org:8765/{charge_point_id}".format(charge_point_id=charge_point_id)
            ) as ws:
                request = cp.on_data_transfer(
                    vendor_id=vendor_id,
                    message_id=message_id,
                    data=data
                )
                response = await ws.send(request)

                logging.info(f"DataTransfer response received: {response}")
        except websockets.exceptions.WebSocketException as e:
            logging.error(f"WebSocket connection error: {e}")
        except Exception as e:
            logging.error(f"Error during DataTransfer: {e}")

    async def store_transaction_details(self, data):
        db = mongoClient['EV_Stations']
        collectionTransactions = db['transactions']
        collectionStations = db['stations']
        collectionRemote = db['remote']

        station = collectionStations.find_one({'sn': data['sn']})
        k = station['increment']
        data['nr'] = k
        k += 1
        collectionStations.update_one({'sn': data['sn']}, {'$set': {'increment': k}})

        try:
            if data['finalAmount'] == 0:
                collectionRemote.insert_one(data)
                logging.info("Transaction details stored in remote")
                print("Transaction details stored in remote")
            else:
                collectionTransactions.insert_one(data)
                logging.info("Transaction details stored in transactions")
                print("Transaction details stored in transactions")
        except Exception as e:
            logging.error(f"Error storing transaction details in MongoDB: {e}")

async def on_connect(websocket, path):
    """For every new charge point that connects, create a ChargePoint
    instance and start listening for messages."""
    try:
        requested_protocols = websocket.request_headers["Sec-WebSocket-Protocol"]
        logging.info("Requested Protocols: %s", requested_protocols)
    except KeyError:
        logging.error("Client hasn't requested any Subprotocol. Closing Connection")
        return await websocket.close()
    if websocket.subprotocol:
        logging.info("Protocols Matched: %s", websocket.subprotocol)
    else:
        # In the websockets lib if no subprotocols are supported by the
        # client and the server, it proceeds without a subprotocol,
        # so we have to manually close the connection.
        logging.warning(
            "Protocols Mismatched | Expected Subprotocols: %s,"
            " but client supports  %s | Closing connection",
            websocket.available_subprotocols,
            requested_protocols,
        )
        return await websocket.close()

    charge_point_id = path.strip("/")
    cp_instance = ChargePoint(charge_point_id, websocket)

    ChargePoint.connected_charge_points[charge_point_id] = cp_instance
    logging.info("Connected Charge Points: %s", list(ChargePoint.connected_charge_points.keys()))
    print("Connected Charge Points:", list(ChargePoint.connected_charge_points.keys()))

    db = mongoClient['EV_Stations']
    collection = db['stations']
    try:
        collection.update_one({'sn': charge_point_id}, {'$set': {'status': 'connected'}})
    except Exception as e:
        logging.error(f"Error updating status in DB: {e}")

    queue_name = f"charge_point_queue_{charge_point_id}"

    asyncio.create_task(receive_messages_from_rabbitmq(queue_name, cp_instance, charge_point_id))

    if path == "/firmware":
        await handle_firmware_request(websocket, path)

    try:
        await cp_instance.start()
    except websockets.exceptions.ConnectionClosed:
        del ChargePoint.connected_charge_points[charge_point_id]
        try:
            collection.update_one({'sn': charge_point_id}, {'$set': {'status': 'disconnected'}})
        except Exception as e:
            logging.error(f"Error updating status in DB: {e}")
        logging.info("Charge Point %s disconnected.", charge_point_id)
        print(f"{charge_point_id} disconnected")

        current_time_utc = datetime.now(timezone.utc)

        # Convert UTC time to GMT+2
        gmt_plus_2 = current_time_utc + timedelta(hours=3)

        station = collection.find_one({'sn': charge_point_id})

        to_number = "+40773357791"
        message_body = f"Statia {station.get('name')} a avut un defect tehnic la ora: {gmt_plus_2}!"
        send_api_sms(to_number, message_body)

        connection = await connect("amqp://guest:guest@arsek-ws.duckdns.org:5672")
        channel = await connection.channel()
        await channel.queue_delete(queue_name)
        await connection.close()

async def handle_firmware_request(websocket, path):
    if path == "/firmware":
        filename = os.path.join(FIRMWARE_DIR, "xchargerNew.apk")
        if os.path.exists(filename):
            with open(filename, 'rb') as file:
                while chunk := file.read(1024):
                    await websocket.send(chunk)
        else:
            await websocket.send("File not found")
    else:
        await websocket.send("Invalid path")

async def receive_messages_from_rabbitmq(queue_name, charge_point, charge_point_id):
    connection = await connect("amqp://guest:guest@arsek-ws.duckdns.org:5672")
    channel = await connection.channel()
    queue = await channel.declare_queue(queue_name)
    async for message in queue:
        try:
            message_body = json.loads(message.body.decode("utf-8"))
            print(f" Received message: {message_body}")
            message_type = message_body.get("type")

            if message_type == "change_availability":
                connector_id = message_body.get("connector_id")
                availability_type = message_body.get("availability_type")
                asyncio.create_task(
                    charge_point.change_availability(connector_id, availability_type))
                
            elif message_type == "get_diagnostics":
                location = message_body.get("location")
                retries = message_body.get("retries")
                retryInterval = message_body.get("retryInterval")
                asyncio.create_task(
                    charge_point.get_diagnostics(location, retries, retryInterval))
            
            elif message_type == "update_firmware":
                location = "ws://arsek-ws.duckdns.org:8765/firmware"
                retrieve_date = "2023-06-15T10:00:00Z"  # Example retrieve date
                charge_point.send_update_firmware(charge_point_id=charge_point_id, location=location, retrieve_date=retrieve_date)
                # location = message_body.get("location")
                # retrieve_date = message_body.get("retrieve_date")
                # asyncio.create_task(
                #     charge_point.update_firmware(location, retrieve_date))
                
            elif message_type == "change_configuration":
                key = message_body.get("key")
                value = message_body.get("value")
                asyncio.create_task(
                    charge_point.change_configuration(key, value))
            
            elif message_type == "reset":
                reset_type = message_body.get("reset_type")
                asyncio.create_task(
                    charge_point.reset(reset_type))
            
            elif message_type == "remote_start_transaction":
                connector_id = message_body.get("connector_id")
                characters = string.ascii_letters + string.digits
                code = ''.join(random.choices(characters, k=10))
                id_tag = code
                asyncio.create_task(
                    charge_point.remote_start_transaction(connector_id, id_tag))
            
            elif message_type == "remote_stop_transaction":
                db = mongoClient['EV_Stations']
                collection = db['stations']
                station_data = collection.find_one({'sn': charge_point_id})
                transaction_id = station_data.get('transactionId')
                asyncio.create_task(
                    charge_point.remote_stop_transaction(transaction_id))
                
            elif message_type == "data_transfer_tariff":
                fee_service = message_body.get("fee_service")
                prepayment_amount = message_body.get("prepayment_amount")
                kw_price = message_body.get("kw_price")
                new_tariff_data = {
                    "feeId": "G-1024",
                    "feeService": fee_service,
                    "currencyType": "RON",
                    "prepaymentAmount": prepayment_amount,
                    "timedPrice": [[0, 0, kw_price, 0]]
                }
                asyncio.create_task(
                    charge_point.data_transfer(vendor_id="xcharge", message_id="tariff", data=json.dumps(new_tariff_data)))
                
            elif message_type == "data_transfer_prepaymentValues":
                first_price = message_body.get("first_price")
                second_price = message_body.get("second_price")
                third_price = message_body.get("third_price")
                fourth_price = message_body.get("fourth_price")
                new_price_data = {
                    "prepaymentOptions": [[first_price, second_price, third_price, fourth_price]]
                }
                asyncio.create_task(
                    charge_point.data_transfer(vendor_id="xcharge", message_id="prepaymentValues", data=json.dumps(new_price_data)))

            else:
                print(f"Unhandled message type: {message_type}")

            await message.ack()
            
        except json.decoder.JSONDecodeError as e:
            print(f"Error decoding JSON: {e}")

    await connection.close()

load_dotenv()

SMSAPI_TOKEN = os.getenv('SMSAPI_TOKEN')

def send_api_sms(to_number, message_body):
    url = "https://api.smsapi.com/sms.do"
    headers = {
        'Authorization': f'Bearer {SMSAPI_TOKEN}'  # Use the Bearer token for authentication
    }
    data = {
        'to': to_number,                 # The recipient phone number in international format
        'message': message_body,         # The content of the message
        'from': 'Arsek',        # Optional: Sender name (if configured in your SMSAPI account)
    }

    try:
        response = requests.post(url, headers=headers, data=data)
        response.raise_for_status()  # Raises an HTTPError for bad responses (4xx or 5xx)

        # Print the raw response content to inspect what is being returned
        print(f"Raw response: {response.text}")

        # Check if the response is in JSON format
        try:
            response_data = response.json()
            print(f"Message sent successfully! Response: {response_data}")
        except ValueError:
            print("Received a non-JSON response. Check the response format.")

    except requests.exceptions.RequestException as e:
        print(f"An error occurred: {e}")

async def main():
    server = await websockets.serve(
        on_connect, "192.168.27.10", 8765, subprotocols=["ocpp1.6"], ping_timeout=None
    )
    logging.info("Server Started listening to new connections...")
    print("Server started")

    await server.wait_closed()

if __name__ == "__main__":
    asyncio.run(main())
